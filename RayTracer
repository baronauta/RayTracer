#!/usr/bin/env julia

#_______________________________________________________________________________________
#     LICENSE NOTICE: European Union Public Licence (EUPL) v.1.2
#     __________________________________________________________
#
#   This file is licensed under the European Union Public Licence (EUPL), version 1.2.
#
#   You are free to use, modify, and distribute this software under the conditions
#   of the EUPL v.1.2, as published by the European Commission.
#
#   Obligations include:
#     - Retaining this notice and the licence terms
#     - Providing access to the source code
#     - Distributing derivative works under the same or a compatible licence
#
#   Full licence text: see the LICENSE file or visit https://eupl.eu
#
#   Disclaimer:
#     Unless required by applicable law or agreed to in writing,
#     this software is provided "AS IS", without warranties or conditions
#     of any kind, either express or implied.
#
#_______________________________________________________________________________________

#❗For name generation logic, see misc.jl

using Pkg
Pkg.activate(normpath(@__DIR__))

using RayTracer
using Comonicon
using Dates

# ─────────────────────────────────────────────────────────────
# PATH TRACER
# ─────────────────────────────────────────────────────────────

"""
Path tracer command to render a scene.

Each execution produces two output images:
- a high dynamic range `.pfm` file
- a tone-mapped image (`.png`, `.jpeg`, or `.tif`)

Both images are saved in the `render/` folder. The tone-mapped image is generated using a basic built-in tone mapping, which may not produce optimal results for all scenes.  
For higher-quality control, load the `.pfm` file and apply a custom tone mapping using the `tonemapping` function.

Note: This command uses the path tracing algorithm, that estimates a solution of the rendering equation via Monte Carlo integration.
    It allows to obtain an exact solution for the rendering equation, although rendering and producing the `.pfm` file can be time-consuming.

# Args

- `scene_file`: Path to the scene description file (String).
- `width`: Width of the output image (Integer).
- `height`: Height of the output image (Integer).

# Options

- `--output-name=<String>`: Base name for the output image files.  
  If not provided, a timestamped name like `pthtrc_2025-06-07_135023` will be used.  
  Output files will be saved as `render_<scene_name>/<name>.<ext>` and `render_<scene_name>/<name>.pfm`.

- `--extension=<String>`: File format for the tone-mapped image (`.png`, `.jpeg`, or `.tif`). Default: `.png`.

- `--angle=<float>`: Angle for rotating the camera around the Z axis.  
  The distance from the origin is maintained.  
  Useful for quickly changing the view without modifying the `scene_file` (default: `0.0`).

- `--n-rays=<Integer>`: Number of rays per pixel (default: `5`).
- `--max-depth=<Integer>`: Maximum ray recursion depth (default: `5`).
- `--russian-roulette-limit=<Integer>`: Depth at which to start Russian roulette termination (default: `3`).
- `--clamping=<String>`: Clamping method to apply; choose between `hard` and `soft`. (default=`soft`).
"""
Comonicon.@cast function pathtracer(
    scene_file, 
    width, 
    height; 
    output_name::String="",
    extension::String = "", # useful fix-it although without output name (so timestamp.extension)
    angle::Float64=0.0,
    n_rays::Int=5,
    max_depth::Int=5,
    russian_roulette_limit::Int=3,
    clamping::String="soft",
    )

    try
        print_welcome()
        println("📂 Preparing to parse the scene...")
        # Determine the correct output file extension and construct output paths.
        # This handles cases where the user may or may not specify output name and/or extension.
        # If no output name is given, a timestamped name inside a folder named after the scene is created.
        extension, ldr_path, pfm_path = RayTracer.choose_name(output_name, extension, scene_file, "pthtrc")

        # check correct output extension
        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end

        # convert width e height to Int
        img_width = parse(Int, width)
        img_height = parse(Int, height)
        # check if there are variables passed from outside (e.g. angle, calculate aspect_ratio)
        aspect_ratio = img_width/img_height
        variables = Dict(
            "angle" => angle,
            "aspect_ratio" => aspect_ratio,
            )

        # Parse the scene from text file
        scene = open(scene_file, "r") do io
            instream = RayTracer.InputStream(io, scene_file)
            RayTracer.parse_scene(instream; variables)
        end
        println("✓ Scene parsing completed.")

        println("🖼️  Setting up the image canvas and camera...")
        # Prepare the canva to draw on
        img = HdrImage(img_width, img_height)
        # Prepare the environment made of the canva and the observer
        tracer = ImageTracer(img, scene.camera)
        println("✓ Canvas and camera setup completed.")
        
        println("🚀 Starting ray tracing (this may take a while)...\n")
        # RayTracing algorithm that need as input ...
        pcg = PCG()
        f =
            ray -> path_tracer(
                scene.world,
                ray,
                pcg;
                bkg_color = BLACK,
                n_rays = n_rays,
                max_depth = max_depth,
                russian_roulette_limit = russian_roulette_limit,
            )


        RayTracer.fire_all_rays!(tracer, f; progress_flag = true)
        

        write(pfm_path, img)
        
        # Basic tone mapping
        clamp = Symbol(clamping)
        println("\n\nApplying basic tone mapping...\n")
        RayTracer.tonemapping!(img; clamp)
        RayTracer.write_ldr_image(ldr_path, img)

        println("✅ Rendering completed successfully. Output files:")
        println("  • Tone-mapped image ($extension): $ldr_path")
        println("  • High dynamic range image (.pfm): $pfm_path\n")

    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# ─────────────────────────────────────────────────────────────
# FLAT TRACER
# ─────────────────────────────────────────────────────────────

"""
Flat tracer command to render a 3D scene with a minimal ray tracer algorithm.

This tool generates two output images for each rendering:
- a high dynamic range `.pfm` file
- a tone-mapped image (`.png`, `.jpeg`, or `.tif`)

Both images are saved in the `render/` folder. The tone-mapped image is generated using a basic built-in tone mapping, which may not produce optimal results for all scenes.  
For higher-quality control, load the `.pfm` file and apply a custom tone mapping using the `tonemapping` function.

Note: This algorithm returns the sum of the surface color and
    emitted radiance at the intersection point of a `ray`.
    If the ray does not intersect any object, the function returns `bkg_color`.

    This tracer ignores lighting, shadows, and reflections, and is typically used
    for quick previews, debugging geometry, or visualizing base materials and emissive surfaces.

# Args

- `scene_file`: Path to the scene description file (String).
- `width`: Width of the output image (Integer).
- `height`: Height of the output image (Integer).

# Options

- `--output-name=<String>`: Base name for the output image files.  
  If not provided, a timestamped name like `flttrc_2025-06-07_135023` will be used.  
  Output files will be saved as `render_<scene_name>/<name>.<ext>` and `render_<scene_name>/<name>.pfm`.

- `--extension=<String>`: File format for the tone-mapped image (`.png`, `.jpeg`, or `.tif`). Default: `.png`.

- `--angle=<float>`: Angle for rotating the camera around the Z axis.  
  The distance from the origin is maintained.  
  Useful for quickly changing the view without modifying the `scene_file` (default: `0.0`).
- `--clamping=<String>`: Clamping method to apply; choose between `hard` and `soft`. (default=`soft`).
"""
Comonicon.@cast function flattracer(
    scene_file, 
    width, 
    height; 
    output_name::String="",
    extension::String = "",
    angle::Float64=0.0,
    clamping::String="soft",
    )

    try
        print_welcome()
        println("📂 Preparing to parse the scene...")
        # Determine the correct output file extension and construct output paths.
        # This handles cases where the user may or may not specify output name and/or extension.
        # If no output name is given, a timestamped name inside a folder named after the scene is created.
        extension, ldr_path, pfm_path = RayTracer.choose_name(output_name, extension, scene_file, "flttrc")

        # check correct output extension
        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end

        # convert width e height to Int
        img_width = parse(Int, width)
        img_height = parse(Int, height)
        # check if there are variables passed from outside (e.g. angle, calculate aspect_ratio)
        aspect_ratio = img_width/img_height
        variables = Dict(
            "angle" => angle,
            "aspect_ratio" => aspect_ratio,
            )

        # Parse the scene from text file
        scene = open(scene_file, "r") do io
            instream = RayTracer.InputStream(io, scene_file)
            RayTracer.parse_scene(instream; variables)
        end
        println("✓ Scene parsing completed.")

        println("🖼️  Setting up the image canvas and camera...")
        # Prepare the canva to draw on
        img = HdrImage(img_width, img_height)
        # Prepare the environment made of the canva and the observer
        tracer = ImageTracer(img, scene.camera)
        println("✓ Canvas and camera setup completed.")
        
        println("🚀 Starting ray tracing (this may take a while)...\n")
        # RayTracing algorithm that need as input ...
        f =
            ray -> flat_tracer(
                scene.world,
                ray;
                bkg_color = BLACK,
            )


        RayTracer.fire_all_rays!(tracer, f; progress_flag = true)
        println("\n")

        write(pfm_path, img)
        
        # Basic tone mapping
        clamp = Symbol(clamping)
        println("\n\nApplying basic tone mapping...\n")
        RayTracer.tonemapping!(img; clamp)
        RayTracer.write_ldr_image(ldr_path, img)

        println("✅ Rendering completed successfully. Output files:")
        println("  • Tone-mapped image ($extension): $ldr_path")
        println("  • High dynamic range image (.pfm): $pfm_path\n")

    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# ─────────────────────────────────────────────────────────────
# ON-OFF TRACER
# ─────────────────────────────────────────────────────────────

"""
On-Off tracer command to render a 3D scene with a binary ray tracer algorithm
that returns `WHITE` if the given `ray` intersects
any object in the `world`, and `bkg_color` otherwise.

This is a basic tracer useful for debugging or silhouette rendering.

This tool generates two output images for each rendering:
- a high dynamic range `.pfm` file
- a tone-mapped image (`.png`, `.jpeg`, or `.tif`)

Both images are saved in the `render/` folder. The tone-mapped image is generated using a basic built-in tone mapping, which may not produce optimal results for all scenes.  
For higher-quality control, load the `.pfm` file and apply a custom tone mapping using the `tonemapping` function.

# Args

- `scene_file`: Path to the scene description file (String).
- `width`: Width of the output image (Integer).
- `height`: Height of the output image (Integer).

# Options

- `--output-name=<String>`: Base name for the output image files.  
  If not provided, a timestamped name like `onoftrc_2025-06-07_135023` will be used.  
  Output files will be saved as `render_<scene_name>/<name>.<ext>` and `render_<scene_name>/<name>.pfm`.

- `--extension=<String>`: File format for the tone-mapped image (`.png`, `.jpeg`, or `.tif`). Default: `.png`.

- `--angle=<float>`: Angle for rotating the camera around the Z axis.  
  The distance from the origin is maintained.  
  Useful for quickly changing the view without modifying the `scene_file` (default: `0.0`).
- `--clamping=<String>`: Clamping method to apply; choose between `hard` and `soft`. (default=`soft`).
"""
Comonicon.@cast function onofftracer(
    scene_file, 
    width, 
    height; 
    output_name::String="",
    extension::String = "",
    angle::Float64=0.0,
    clamping::String="soft",
    )

    try
        print_welcome()
        println("📂 Preparing to parse the scene...")
        # Determine the correct output file extension and construct output paths.
        # This handles cases where the user may or may not specify output name and/or extension.
        # If no output name is given, a timestamped name inside a folder named after the scene is created.
        extension, ldr_path, pfm_path = RayTracer.choose_name(output_name, extension, scene_file, "onoftrc")

        # check correct output extension
        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end

        # convert width e height to Int
        img_width = parse(Int, width)
        img_height = parse(Int, height)
        # check if there are variables passed from outside (e.g. angle, calculate aspect_ratio)
        aspect_ratio = img_width/img_height
        variables = Dict(
            "angle" => angle,
            "aspect_ratio" => aspect_ratio,
            )

        # Parse the scene from text file
        scene = open(scene_file, "r") do io
            instream = RayTracer.InputStream(io, scene_file)
            RayTracer.parse_scene(instream; variables)
        end
        println("✓ Scene parsing completed.")

        println("🖼️  Setting up the image canvas and camera...")
        # Prepare the canva to draw on
        img = HdrImage(img_width, img_height)
        # Prepare the environment made of the canva and the observer
        tracer = ImageTracer(img, scene.camera)
        println("✓ Canvas and camera setup completed.")
        
        println("🚀 Starting ray tracing (this may take a while)...\n")
        # RayTracing algorithm that need as input ...
        f =
            ray -> onoff_tracer(
                scene.world,
                ray;
                bkg_color = BLACK,
            )


        RayTracer.fire_all_rays!(tracer, f; progress_flag = true)
        println("\n")

        write(pfm_path, img)
        
        # Basic tone mapping
        clamp = Symbol(clamping)
        println("\n\nApplying basic tone mapping...\n")
        RayTracer.tonemapping!(img; clamp)
        RayTracer.write_ldr_image(ldr_path, img)

        println("✅ Rendering completed successfully. Output files:")
        println("  • Tone-mapped image ($extension): $ldr_path")
        println("  • High dynamic range image (.pfm): $pfm_path\n")

    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# ─────────────────────────────────────────────────────────────
# TONEMAPPING
# ─────────────────────────────────────────────────────────────

"""
Perform tone mapping on an HDR image loaded from a PFM file, then save it as an LDR image.

# Args

- `input_file`: Path to the input HDR image file (must have a `.pfm` extension).

# Options
- `--output-name=<String>`: Custom name for the output tone-mapped image (default: auto-generated from parameters).
- `--out-ext=<String>`: Desired file extension for the output LDR image (e.g., ".png", ".jpg").
                        Defaults to ".png".
- `--mean=<String>`: Method to compute the luminosity mean during normalization. Defaults use "max_min" method.
- `--weights=<String>`: Weights for luminosity when mean=weighted. Format:< "[w1, w2, w3]" >.
- `--a=<Float64>`: A scaling factor applied during image normalization. Defaults to 1.0.
- `--gamma=<Float64>`: The gamma correction value applied when writing the LDR image. Defaults to 1.0.
- `--clamping=<String>`: Clamping method to apply; choose between `hard` and `soft`. (default=`soft`).
"""
Comonicon.@cast function tonemapping(
    input_file;
    output_name::String="",
    out_ext::String = "",
    mean::String="max_min",
    weights::String="[]",  # default to empty
    a::Float64 = 1.,
    gamma::Float64=1.,
    clamping::String="soft",
)
    try
        print_welcome()
        # Check extension
        println("Reading .pfm image...")
        RayTracer.expected_extension(input_file, [".pfm"])

        (weights=="[]") ? (weights = nothing) : (weights = parse.(Float64, strip.(split(strip(weights, ['[', ']']), ","))))
        
        println("🖼️  Applying tone mapping...")
        clamp = Symbol(clamping)
        img = RayTracer.read_pfm_image(input_file)
        RayTracer.tonemapping!(
            img;
            mean_type = mean,
            weights = weights,
            a = a
            clamp=clamp,
        )

        # Create the default name (summarizing params, see misc.jl)
        base_output_name = if isempty(output_name)
            # Get filename without its original extension
            RayTracer.tonemapping_name(
                splitext(input_file)[1],
                mean,
                weights,
                a,
                gamma,
            )
        else
            splitext(output_name)[1] # Get output_name without its original extension
        end
        
        extension = RayTracer.choose_ext(output_name, out_ext)

        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end
        newfilename = base_output_name * extension
        @info "Saving image to disk...\n"
        RayTracer.write_ldr_image(newfilename, img; gamma = gamma)
        println("\n✅ Tone mapping completed successfully. Output file:")
        println("  • $newfilename")
    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# Use a single @main somewhere to define the entry.
# Leave @main empty; it just activates the CLI parser and dispatcher.
Comonicon.@main