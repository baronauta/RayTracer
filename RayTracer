#!/usr/bin/env julia

#_______________________________________________________________________________________
#     LICENSE NOTICE: European Union Public Licence (EUPL) v.1.2
#     __________________________________________________________
#
#   This file is licensed under the European Union Public Licence (EUPL), version 1.2.
#
#   You are free to use, modify, and distribute this software under the conditions
#   of the EUPL v.1.2, as published by the European Commission.
#
#   Obligations include:
#     - Retaining this notice and the licence terms
#     - Providing access to the source code
#     - Distributing derivative works under the same or a compatible licence
#
#   Full licence text: see the LICENSE file or visit https://eupl.eu
#
#   Disclaimer:
#     Unless required by applicable law or agreed to in writing,
#     this software is provided "AS IS", without warranties or conditions
#     of any kind, either express or implied.
#
#_______________________________________________________________________________________

using Pkg
Pkg.activate(normpath(@__DIR__))

using RayTracer
using Comonicon
using Dates

#--- parsing extension functions ---

"""
Extracts the file extension from a given `filename`.

# Returns
- The extension string (including the dot), e.g. ".png", or `nothing` if no extension is found.
"""
    function get_extension_if_given(filename::String)
        ext = splitext(filename)[2]
        return isempty(ext) ? nothing : ext
    end

"""
Determines the appropriate file extension to use for output.

# Returns
- The extension to use (including the dot), giving priority to the explicit `extension`.
- If no extension specified and none in filename, defaults to ".png".

# Notes
- If both filename and explicit extension have different extensions, a warning is printed and explicit extension is used.
"""
    function choose_ext(filename::String, extension::String)
        # Extract the extension from the output name, if it has one
        ext_in_filename = get_extension_if_given(filename)

        # Case 1: No extension was passed via --extension
        if extension == ""
            # No extension in output name → use default ".png"
            isnothing(ext_in_filename) && return ".png"

            # Extension found in output name → use that
            !isnothing(ext_in_filename) && return ext_in_filename
            
        else # Case 2: --extension was explicitly passed

            # Both extensions are present and they differ → show a warning
            if(!isnothing(ext_in_filename) && (extension != ext_in_filename))
                @warn "\n⚠️  Warning: extension in output name ('$ext_in_filename') doesn't match the one specified ('$extension'). Using the specified one.\n")
            end
            return extension
        end
    end

"""
Constructs output file paths and directories based on input parameters.

# Arguments
- `output_name::String`: The base name of the output file.
- `extension::String`: The desired file extension (may be empty).
- `scene_file::String`: Path to the scene file used for rendering.
- `tracer::String`: A prefix string indicating the tracer type (used in default naming).

# Returns
- `extension`: The chosen file extension (including the dot).
- `ldr_path`: Full path for the tone-mapped output image file.
- `pfm_path`: Full path for the high dynamic range `.pfm` output file.

# Behavior
- If no output name is provided, creates a timestamped name inside a directory named after the scene file.
- Ensures the output directory exists.
- If output name is provided, uses it to build output paths with correct extensions.
"""
function choose_name(output_name::String, extension::String, scene_file::String, tracer::String)
    # check if an output name is declared, if not use timestamp for default.
    # For default name i want to create a folder with the scene name.
    if isempty(output_name)
        extension = choose_ext(output_name, extension) # here i choose the default or the passed one 
        scene_name = splitext(basename(scene_file))[1]
        timestamp = Dates.format(now(), "yyyy-mm-dd_HHMMSS")
        output_name = "$(tracer)_$timestamp"
        base_path = "render_$(scene_name)"

        # make the path for output images
        mkpath(base_path)
        ldr_path = joinpath(base_path, output_name * extension)
        pfm_path = joinpath(base_path, output_name * ".pfm")

        return extension, ldr_path, pfm_path
    else
        extension = choose_ext(output_name, extension)

        # make the path for output images
        name = splitext(output_name)[1]
        ldr_path = joinpath(name * extension)
        pfm_path = joinpath(name * ".pfm")

        return extension, ldr_path, pfm_path
    end
end

# ─────────────────────────────────────────────────────────────
# PATH TRACER
# ─────────────────────────────────────────────────────────────

"""
Path tracer command to render a scene.

Each execution produces two output images:
- a high dynamic range `.pfm` file
- a tone-mapped image (`.png`, `.jpeg`, or `.tif`)

Both images are saved in the `render/` folder. The tone-mapped image is generated using a basic built-in tone mapping, which may not produce optimal results for all scenes.  
For higher-quality control, load the `.pfm` file and apply a custom tone mapping using the `tonemapping` function.

Note: This command uses the path tracing algorithm, that estimates a solution of the rendering equation via Monte Carlo integration.
    It allows to obtain an exact solution for the rendering equation, although rendering and producing the `.pfm` file can be time-consuming.

# Args

- `scene_file`: Path to the scene description file (String).
- `width`: Width of the output image (Integer).
- `height`: Height of the output image (Integer).

# Options

- `--output-name=<String>`: Base name for the output image files.  
  If not provided, a timestamped name like `pthtrc_2025-06-07_135023` will be used.  
  Output files will be saved as `render_<scene_name>/<name>.<ext>` and `render_<scene_name>/<name>.pfm`.

- `--extension=<String>`: File format for the tone-mapped image (`.png`, `.jpeg`, or `.tif`). Default: `.png`.

- `--angle=<float>`: Angle for rotating the camera around the Z axis.  
  The distance from the origin is maintained.  
  Useful for quickly changing the view without modifying the `scene_file` (default: `0.0`).

- `--n-rays=<Integer>`: Number of rays per pixel (default: `5`).
- `--max-depth=<Integer>`: Maximum ray recursion depth (default: `5`).
- `--russian-roulette-limit=<Integer>`: Depth at which to start Russian roulette termination (default: `3`).
"""
Comonicon.@cast function pathtracer(
    scene_file, 
    width, 
    height; 
    output_name::String="",
    extension::String = "", # useful fix-it although without output name (so timestamp.extension)
    angle::Float64=0.0,
    n_rays::Int=5,
    max_depth::Int=5,
    russian_roulette_limit::Int=3,
    )

    try
        println("📂 Preparing to parse the scene...")
        # Determine the correct output file extension and construct output paths.
        # This handles cases where the user may or may not specify output name and/or extension.
        # If no output name is given, a timestamped name inside a folder named after the scene is created.
        extension, ldr_path, pfm_path = choose_name(output_name, extension, scene_file, "pthtrc")

        # check correct output extension
        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end

        # convert width e height to Int
        img_width = parse(Int, width)
        img_height = parse(Int, height)
        # check if there are variables passed from outside (e.g. angle, calculate aspect_ratio)
        aspect_ratio = img_width/img_height
        variables = Dict(
            "angle" => angle,
            "aspect_ratio" => aspect_ratio,
            )

        # Parse the scene from text file
        scene = open(scene_file, "r") do io
            instream = RayTracer.InputStream(io, scene_file)
            RayTracer.parse_scene(instream; variables)
        end
        println("✓ Scene parsing completed.")

        println("🖼️  Setting up the image canvas and camera...")
        # Prepare the canva to draw on
        img = HdrImage(img_width, img_height)
        # Prepare the environment made of the canva and the observer
        tracer = ImageTracer(img, scene.camera)
        println("✓ Canvas and camera setup completed.")
        
        println("🚀 Starting ray tracing (this may take a while)...\n")
        # RayTracing algorithm that need as input ...
        pcg = PCG()
        f =
            ray -> path_tracer(
                scene.world,
                ray,
                pcg;
                bkg_color = BLACK,
                n_rays = n_rays,
                max_depth = max_depth,
                russian_roulette_limit = russian_roulette_limit,
            )


        RayTracer.fire_all_rays!(tracer, f; progress_flag = true)
        

        write(pfm_path, img)
        
        # basic tone mapping
        println("\n\nApplying basic tone mapping...\n")
        RayTracer.normalize_image!(img)
        RayTracer.clamp_image!(img)
        RayTracer.write_ldr_image(ldr_path, img)

        println("✅ Rendering completed successfully. Output files:")
        println("  • Tone-mapped image ($extension): $ldr_path")
        println("  • High dynamic range image (.pfm): $pfm_path\n")

    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# ─────────────────────────────────────────────────────────────
# FLAT TRACER
# ─────────────────────────────────────────────────────────────

"""
Flat tracer command to render a 3D scene with a minimal ray tracer algorithm.

This tool generates two output images for each rendering:
- a high dynamic range `.pfm` file
- a tone-mapped image (`.png`, `.jpeg`, or `.tif`)

Both images are saved in the `render/` folder. The tone-mapped image is generated using a basic built-in tone mapping, which may not produce optimal results for all scenes.  
For higher-quality control, load the `.pfm` file and apply a custom tone mapping using the `tonemapping` function.

Note: This algorithm returns the sum of the surface color and
    emitted radiance at the intersection point of a `ray`.
    If the ray does not intersect any object, the function returns `bkg_color`.

    This tracer ignores lighting, shadows, and reflections, and is typically used
    for quick previews, debugging geometry, or visualizing base materials and emissive surfaces.

# Args

- `scene_file`: Path to the scene description file (String).
- `width`: Width of the output image (Integer).
- `height`: Height of the output image (Integer).

# Options

- `--output-name=<String>`: Base name for the output image files.  
  If not provided, a timestamped name like `flttrc_2025-06-07_135023` will be used.  
  Output files will be saved as `render_<scene_name>/<name>.<ext>` and `render_<scene_name>/<name>.pfm`.

- `--extension=<String>`: File format for the tone-mapped image (`.png`, `.jpeg`, or `.tif`). Default: `.png`.

- `--angle=<float>`: Angle for rotating the camera around the Z axis.  
  The distance from the origin is maintained.  
  Useful for quickly changing the view without modifying the `scene_file` (default: `0.0`).
"""
Comonicon.@cast function flattracer(
    scene_file, 
    width, 
    height; 
    output_name::String="",
    extension::String = "",
    angle::Float64=0.0,
    )

    try
        println("📂 Preparing to parse the scene...")
        # Determine the correct output file extension and construct output paths.
        # This handles cases where the user may or may not specify output name and/or extension.
        # If no output name is given, a timestamped name inside a folder named after the scene is created.
        extension, ldr_path, pfm_path = choose_name(output_name, extension, scene_file, "flttrc")

        # check correct output extension
        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end

        # convert width e height to Int
        img_width = parse(Int, width)
        img_height = parse(Int, height)
        # check if there are variables passed from outside (e.g. angle, calculate aspect_ratio)
        aspect_ratio = img_width/img_height
        variables = Dict(
            "angle" => angle,
            "aspect_ratio" => aspect_ratio,
            )

        # Parse the scene from text file
        scene = open(scene_file, "r") do io
            instream = RayTracer.InputStream(io, scene_file)
            RayTracer.parse_scene(instream; variables)
        end
        println("✓ Scene parsing completed.")

        println("🖼️  Setting up the image canvas and camera...")
        # Prepare the canva to draw on
        img = HdrImage(img_width, img_height)
        # Prepare the environment made of the canva and the observer
        tracer = ImageTracer(img, scene.camera)
        println("✓ Canvas and camera setup completed.")
        
        println("🚀 Starting ray tracing (this may take a while)...\n")
        # RayTracing algorithm that need as input ...
        f =
            ray -> flat_tracer(
                scene.world,
                ray;
                bkg_color = BLACK,
            )


        RayTracer.fire_all_rays!(tracer, f; progress_flag = true)
        println("\n")

        write(pfm_path, img)
        
        # basic tone mapping
        println("\n\nApplying basic tone mapping...\n")
        RayTracer.normalize_image!(img)
        RayTracer.clamp_image!(img)
        RayTracer.write_ldr_image(ldr_path, img)

        println("✅ Rendering completed successfully. Output files:")
        println("  • Tone-mapped image ($extension): $ldr_path")
        println("  • High dynamic range image (.pfm): $pfm_path\n")

    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# ─────────────────────────────────────────────────────────────
# ON-OFF TRACER
# ─────────────────────────────────────────────────────────────

"""
On-Off tracer command to render a 3D scene with a binary ray tracer algorithm
that returns `WHITE` if the given `ray` intersects
any object in the `world`, and `bkg_color` otherwise.

This is a basic tracer useful for debugging or silhouette rendering.

This tool generates two output images for each rendering:
- a high dynamic range `.pfm` file
- a tone-mapped image (`.png`, `.jpeg`, or `.tif`)

Both images are saved in the `render/` folder. The tone-mapped image is generated using a basic built-in tone mapping, which may not produce optimal results for all scenes.  
For higher-quality control, load the `.pfm` file and apply a custom tone mapping using the `tonemapping` function.

# Args

- `scene_file`: Path to the scene description file (String).
- `width`: Width of the output image (Integer).
- `height`: Height of the output image (Integer).

# Options

- `--output-name=<String>`: Base name for the output image files.  
  If not provided, a timestamped name like `onoftrc_2025-06-07_135023` will be used.  
  Output files will be saved as `render_<scene_name>/<name>.<ext>` and `render_<scene_name>/<name>.pfm`.

- `--extension=<String>`: File format for the tone-mapped image (`.png`, `.jpeg`, or `.tif`). Default: `.png`.

- `--angle=<float>`: Angle for rotating the camera around the Z axis.  
  The distance from the origin is maintained.  
  Useful for quickly changing the view without modifying the `scene_file` (default: `0.0`).
"""
Comonicon.@cast function onofftracer(
    scene_file, 
    width, 
    height; 
    output_name::String="",
    extension::String = "",
    angle::Float64=0.0,
    )

    try
        println("📂 Preparing to parse the scene...")
        # Determine the correct output file extension and construct output paths.
        # This handles cases where the user may or may not specify output name and/or extension.
        # If no output name is given, a timestamped name inside a folder named after the scene is created.
        extension, ldr_path, pfm_path = choose_name(output_name, extension, scene_file, "onoftrc")

        # check correct output extension
        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end

        # convert width e height to Int
        img_width = parse(Int, width)
        img_height = parse(Int, height)
        # check if there are variables passed from outside (e.g. angle, calculate aspect_ratio)
        aspect_ratio = img_width/img_height
        variables = Dict(
            "angle" => angle,
            "aspect_ratio" => aspect_ratio,
            )

        # Parse the scene from text file
        scene = open(scene_file, "r") do io
            instream = RayTracer.InputStream(io, scene_file)
            RayTracer.parse_scene(instream; variables)
        end
        println("✓ Scene parsing completed.")

        println("🖼️  Setting up the image canvas and camera...")
        # Prepare the canva to draw on
        img = HdrImage(img_width, img_height)
        # Prepare the environment made of the canva and the observer
        tracer = ImageTracer(img, scene.camera)
        println("✓ Canvas and camera setup completed.")
        
        println("🚀 Starting ray tracing (this may take a while)...\n")
        # RayTracing algorithm that need as input ...
        f =
            ray -> onoff_tracer(
                scene.world,
                ray;
                bkg_color = BLACK,
            )


        RayTracer.fire_all_rays!(tracer, f; progress_flag = true)
        println("\n")

        write(pfm_path, img)
        
        # basic tone mapping
        println("\n\nApplying basic tone mapping...\n")
        RayTracer.normalize_image!(img)
        RayTracer.clamp_image!(img)
        RayTracer.write_ldr_image(ldr_path, img)

        println("✅ Rendering completed successfully. Output files:")
        println("  • Tone-mapped image ($extension): $ldr_path")
        println("  • High dynamic range image (.pfm): $pfm_path\n")

    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# ─────────────────────────────────────────────────────────────
# TONEMAPPING
# ─────────────────────────────────────────────────────────────

"""
Performs tone mapping on an HDR (High Dynamic Range) image read from the specified `filename`.
The function reads a PFM image, normalizes its luminance, and then writes the result
as an LDR (Low Dynamic Range) image with a specified extension and gamma correction.

# Args

- `filename`: The path to the input HDR image file (e.g., a PFM file).

# Options

- `--output-name=<String>`: Optional. The desired name for the output LDR image file.
                            If empty, the base name of the input `filename` will be used.
- `--extension=<String>`: The desired file extension for the output LDR image (e.g., ".png", ".jpg").
                        Defaults to ".png". Must be one of the `SUPPORTED_EXTS`.
- `--factor=<Float64>`: A scaling factor applied during image normalization. Defaults to 1.0.
- `--mean=<Symbol>`: The type of mean calculation to use during normalization. Defaults to `:`.
                    (Note: The current `normalize_image!` call explicitly uses `:max_min`.)
- `--gamma=<Float64>`: The gamma correction value applied when writing the LDR image. Defaults to 1.0.
- `--weights=<Vector{Float64}>`: A vector of weights used for luminance calculation during normalization.
                                Defaults to `[1., 1., 1.]` (typically for R, G, B channels).
"""
Comonicon.@cast function tonemapping(
    filename;
    output_name::String="",
    extension::String = "",
    factor::Float64=1.,
    mean::Symbol=:max_min,
    gamma::Float64=1.,
    weights::Vector{Float64}=[1., 1., 1.]
)
    try
        hdrimage = read_pfm_image(filename)
        RayTracer.normalize_image!(
            hdrimage;
            factor = factor,
            lumi = nothing,
            delta = 1e-10,
            mean_type = mean,
            weights = weights,
            )
        RayTracer.clamp_image!(hdrimage)
        # Determine the base output filename
        base_output_name = if isempty(output_name)
            splitext(filename)[1] # Get filename without its original extension
        else
            splitext(output_name)[1] # Get output_name without its original extension
        end
        
        extension = choose_ext(output_name, extension)

        if !(extension in SUPPORTED_EXTS)
            throw(ExtensionError("unsupported file extension. Please use one of: $(join(SUPPORTED_EXTS, ", "))"))
        end
        newfilename = base_output_name * extension
        @info "Saving figure to $newfilename...\n"
        RayTracer.write_ldr_image(newfilename, hdrimage; gamma=gamma)
    catch e
        if isa(e, CustomException)
            println(e)
        else
            rethrow()
        end
    end
end

# Use a single @main somewhere to define the entry.
# Leave @main empty; it just activates the CLI parser and dispatcher.
Comonicon.@main